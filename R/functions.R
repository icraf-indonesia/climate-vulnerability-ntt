# Function to read and clean names of columns from an Excel file
read_excel_custom <- function(path, sheet) {
  readxl::read_xlsx(path, sheet) |> 
    janitor::clean_names()
}

# Function to remove specified columns from a dataframe
remove_columns <- function(df, cols_to_remove) {
  df |> 
    dplyr::select(-all_of(cols_to_remove))
}

# Function to select specified columns from a dataframe
select_columns <- function(df, cols_to_select) {
  df |> 
    dplyr::select(all_of(cols_to_select))
}

# Function to filter rows in a dataframe that contain any NA values
filter_na_rows <- function(df) {
  df |>
    dplyr::filter_all(dplyr::any_vars(is.na(.)))
}

# Function to pivot a dataframe, excluding specified columns and renaming 'variable' and 'value'
pivot_dataframe <- function(df, cols_to_exclude, name_variable, name_value) {
  df |> 
    tidyr::pivot_longer(
      cols = -all_of(cols_to_exclude),
      names_to = name_variable,
      values_to = name_value
    )
}

# Function to calculate summary statistics for each group in a dataframe
calculate_summary_stats <- function(gt_tab) {
  gt_tab |>
    dplyr::summarise(
      min = min(value, na.rm = TRUE),
      max = max(value, na.rm = TRUE),
      median = median(value, na.rm = TRUE),
      # Uncomment the following lines if you need mean and standard deviation
      # mean = mean(value, na.rm = TRUE),
      # sd = sd(value, na.rm = TRUE),
      value_data = list(value),
      .groups = "drop"
    )
}

# Create a gt table with density plots and formatted number columns
create_gt_plot <- function(gt_stat) {
  gt_stat |>
    gt::gt() |> 
    gtExtras::gt_plt_dist(
      value_data,
      type = "density",
      line_color = "blue",
      fill_color = "red"
    ) |>
    gt::fmt_number(columns = c(min, max, median), decimals = 1)
}

# Create a subset of your data that includes the columns relevant for imputation.
prepare_data_subset <- function(data, cols) {
  data[, cols, drop = FALSE]
}

# Perform the imputation using the mice package.
perform_data_imputation <- function(data, m = 5, maxit = 50, method = 'pmm', seed = 500) {
  imputed_data <- mice(data, m = m, maxit = maxit, method = method, seed = seed)
  completed_data <- complete(imputed_data, 1)  # Extract the first imputed dataset
  completed_data
}

# Function to plot ordered loadings
plot_ordered_loadings_ggplot <- function(loadings, pc_num, nvar = 10) {
  # Order indices
  ordered_indices <- order(-abs(loadings[, pc_num]), decreasing = TRUE)
  
  # Create a data frame for ggplot
  data_for_plot <- tibble(
    Variable = rownames(loadings)[ordered_indices],
    Loading = abs(loadings[ordered_indices, pc_num]),
    Color = ifelse(loadings[ordered_indices, pc_num] < 0, "red", "blue")
  ) |> arrange(desc(Loading)) |> top_n(nvar, Loading)

  # Create the plot using ggplot
  barplot_ <- ggplot(data_for_plot, aes(x = reorder(Variable, Loading), y = Loading, fill = Color)) +
    geom_bar(stat = "identity", position = "dodge") +
    coord_flip() +  # Flip coordinates to make it horizontal
    scale_fill_identity() +  # Use the colors defined in the data frame
    labs(title = paste("Loadings for PC", pc_num), x = "", y = "Loading") +
    theme_minimal() +
    theme(axis.text.x = element_text(size = rel(0.9)))+   # Adjust text size as needed
    ylim(c(0,0.5))
  
  return(barplot_)
  }

# Takes the PCA result as input and saves the loading plots to specified file paths
generate_pca_loadings_plots <- function(pca_result, num_pcs = 3, output_dir = "output") {
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Extract the loadings for the specified number of principal components
  loadings <- pca_result$rotation[, 1:num_pcs]
  
  # Plotting and saving each loading plot
  for (i in 1:num_pcs) {
    file_name <- paste0("Loadings for PC", i, ".png")
    file_path <- paste0(output_dir, "/", file_name)
    plot_ordered_loadings_ggplot(loadings, i) |> ggsave(filename = file_path)
  }
}


# Compute total within-cluster sum of squares for different k values
compute_wss <- function(data, max_clusters = 10) {
  wss_values <- sapply(1:max_clusters, function(k) {
    kmeans(data, centers = k, nstart = 25)$tot.withinss
  })
  data.frame(Clusters = 1:max_clusters, WSS = wss_values)
}

# Compute Silhouette Scores:
compute_silhouette_scores <- function(data, min_clusters = 2, max_clusters = 10) {
  set.seed(45)  # Ensure reproducibility
  scores <- sapply(min_clusters:max_clusters, function(k) {
    cluster_result <- kmeans(data, centers = k)
    silhouette_avg <- mean(silhouette(cluster_result$cluster, dist(data))[, "sil_width"])
    silhouette_avg
  })
  data.frame(Clusters = min_clusters:max_clusters, Silhouette = scores)
}

# Plot the first two principal components and color by cluster
plot_kmeans_clusters <- function(components, kmeans_result, pc_x, pc_y) {
  plot_data <- data.frame(components, cluster = as.factor(kmeans_result$cluster))
  ggplot(plot_data, aes(x = .data[[pc_x]], y = .data[[pc_y]], color = cluster)) +
    geom_point() +
    labs(title = paste("K-means Clustering on", pc_x, "and", pc_y, "Principal Components")) +
    theme_minimal()
}

# 3D scatter plot of the first-three PCs
create_3d_scatter_plot <- function(scaled_df, components, kmeans_result) {
  
  # Extract names for labeling
  names_kab_kec <- scaled_df |> 
    select(c(nmkab, nmkec))
  
  # Prepare data for plotting
  plot_data <- data.frame(components, cluster = as.factor(kmeans_result$cluster)) |> 
    bind_cols(names_kab_kec)
  
  # Create the 3D scatter plot
  plot_3d <- plot_ly(
    data = plot_data,
    x = ~PC1,
    y = ~PC2,
    z = ~PC3,
    color = ~cluster,
    type = "scatter3d",
    text = ~paste("Kab./Kota:", nmkab, "<br>Kecamatan:", nmkec),
    mode = "markers"
  )
  plot_3d
}


# Visualise the clusters into a map
process_and_join_geo_cluster <- function(shapefile_path, nm_prov, scaled_df, kmeans_result) {
  # Read the shapefile
  desa <- st_read(shapefile_path)
  
  # Filter based on the 'kdprov' attribute
  desa_filtered <- desa |> filter(nmprov %in% nm_prov) |> 
    select(-c("kddesa", "iddesa"))
  
  # Select and mutate necessary columns
  desa_id_kec <- desa_filtered |> 
    select(nmkab, nmkec, kdprov, kdkab, kdkec) |> 
    mutate(idkec = paste0(kdprov, kdkab, kdkec))|>
    mutate(idkec = as.numeric(idkec))|> 
    group_by(idkec, nmkec, nmkab) |> summarize() 
  
  # Prepare cluster data
  cluster_data <- scaled_df |> 
    select(-c(id, nmkab, nmkec ,nmprov)) |> 
    #dplyr::select(1:9) |>
    bind_cols(tibble (cluster = kmeans_result$cluster))
  
  # Join the cluster data with the geo data
  clusters_ <- desa_id_kec |> left_join(cluster_data, by = "idkec")
  
  clusters_
}


create_leaflet_map <- function(clusters_kec, cluster_lookup) {
  # Ensure clusters_kec is read as an sf object
  if (!inherits(clusters_kec, "sf")) {
    clusters_kec <- st_read(clusters_kec, quiet = TRUE)
  }
  
  # Read the cluster lookup table
  cluster_lookup <- readr::read_csv(cluster_lookup)
  
  
  
  # Join the data with cluster names
  clusters_kec_with_name <- clusters_kec |> right_join(cluster_lookup, by = "cluster") |> 
  mutate_at(.vars = c("cluster", "name"), .funs = as.factor)

  # Set up the color palette
  pal <- colorFactor(palette = "Set1", domain = clusters_kec_with_name$name)
  
  # Constructing the label string
  clusters_kec_with_name$label_content <- with(
    clusters_kec_with_name,
    paste0(
      "<strong>Kabupaten:</strong> ",
      nmkab,
      "<br>",
      "<strong>Kecamatan:</strong> ",
      nmkec,
      "<br>",
      "<strong>Tipologi:</strong> ",
      name
    )
  ) |> lapply(htmltools::HTML)
  
  # Create the leaflet map with HTML-rendered labels
  leaflet_map <- leaflet(clusters_kec_with_name) |>
    addProviderTiles(providers$CyclOSM) |>
    addPolygons(
      fillColor = ~ pal(name),
      weight = 0.5,
      opacity = 1,
      color = "white",
      dashArray = "3",
      fillOpacity = 0.7,
      highlight = highlightOptions(
        weight = 5,
        color = "#666",
        dashArray = "",
        fillOpacity = 0.7,
        bringToFront = TRUE
      ),
      label = ~ label_content,
      labelOptions = labelOptions(noHide = FALSE, direction = 'auto')
    ) |>
    addLegend(pal = pal, values = ~ name, title = "Typology")
  
  return(leaflet_map)
}

# Function to extract numeric values
extract_numeric <- function(cell_value) {
  as.numeric(unlist(strsplit(cell_value, " "))[1])
}

# Function to get color for each value based on its rank in the row
get_row_colors <- function(row_values) {
  rank_values <- rank(row_values)
  colorRampPalette(c("darkblue", "lightyellow", "salmon"))(length(row_values))[rank_values]
}

# Function to create the gt table
create_gt_table <- function(summary_table, all_colors) {
  all_values <- apply(summary_table[2:6], 2, function(row) {
    sapply(row, extract_numeric)
  })
  
  all_values |> as_tibble() |>
    {
      \(x) bind_cols(summary_table[1], x#, 
                    # summary_table[7]
                     )
    }() |>
    gt() |>
    data_color(method = "factor", 
      direction = "row",
      columns = 2:6,
      colors = c("salmon", "lightyellow", "darkblue")
    ) |>
    tab_options(
      container.overflow.x = TRUE,
      container.overflow.y = TRUE
    )
}




